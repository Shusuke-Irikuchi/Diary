# BFFについて

## 調べる前
- GraphQLが登場するイメージ
- Backend For Frontendの頭文字でBFFらしい

## オレオレ調査開始🕵️‍♀️

### 背景
2000年代になってAjax通信が浸透しバックエンド(サーバ）はよりAPIに特化し, フロントエンドはよりUI/UXに特化した構築がなされるようになった。**マイクロサービスアーキテクチャー**
そして,あらゆるクライアントデバイスへの対応やUXの向上, リクエストの制限の対策等としてフロントとバックエンドとの間にサーバを用意してあげる.(こいつが**BFF**)

### 仕様
BFFは主なユースケースを代表的なユースケースをgosyoukai
- APIGateWay
- SSR
- ファイルアップロード
- セッション管理
- WebSocket、Server Sent Events、Long Polling(こいつについては今回は言及しない)

#### APIgateWay
例えば、様々なプラットフォームに対応をしたく,それぞれで出力するデータを制限したくなったときのことを考えます.
```
/api/news?platform=web  //web
/api/news?platform=phone //スマホ
/api/news?platform=game  //ゲーム機器
/api/news?platform=tv //テレビ 
```
![1](https://user-images.githubusercontent.com/56505469/85938182-c6f44280-b945-11ea-9075-37909eb6dd62.jpeg)
これだとAPI側で考慮しきれなくなる場合もあり,コードが重複する可能性もあります.それなら,プラットフォームと対になるようにAPIを用意すればいいじゃないかと思うかもしれませんが,
これだと後から機能追加だったり,同様にコードがプラットフォーム間で重複する可能性があります.そこでどのようにするかというと,下記のようにします.
![IMG_1F73B92B5B8E-1](https://user-images.githubusercontent.com/56505469/85938084-bf806980-b944-11ea-8095-f20c5c3dd814.jpeg)
BFFが各プラットフォームにあったレスポンスを返すようにすることでAPI側の開発効率をあげるだけでなく,プラットホームを増やせるようになりました.
しかしこれだとBFFへの負荷が大きくなってしまうので,各プラットフォームにBFFを用意することでBFFへの負荷を分散させます.ここで注意しなくては行けないのが, ** BFFにAPI側の仕事を任せすぎなことです. **

http/1.1の場合,サーバーのTCPコネクションは最大6つまで可能(6つあるけど,規約に同時接続は2つまでにすべきとある)であるがその分サーバーの負荷が増加してします。
そのため、httpパイプラインという物があるがこれはある特定の通信が遅い場合に後ろの通信を待たせてしまう。(Head of Line Blocking)
そのため,BFFを用意することでリクエストを1つにまとめることが可能になり,リソースを有効的に活用できる.

### BFFの実装について
GraphQLの登場を当人が記憶していたのは次の記事を読んだ覚えがあったらしい.....[フロントエンドに型の秩序を与えるGraphQLとTypeScript](https://www.wantedly.com/companies/wantedly/post_articles/183567)
